# Project Constitution: Physical AI & Humanoid Robotics Textbook + RAG System

## 1. Purpose & Vision

This project aims to develop an AI-native textbook on Physical AI & Humanoid Robotics, complemented by an integrated RAG chatbot and personalization system, for the Panaversity Hackathon.

- **AI-Native Textbook Development**: A methodology where AI actively participates in the content generation, structuring, and enhancement of the textbook, leveraging tools like Docusaurus and Spec-Kit Plus, and authored using Claude Code. This ensures automated, high-quality, and scalable content creation.
- **Spec-Kit Driven Development**: A development paradigm where all software artifacts, including code, documentation, and infrastructure, are generated or guided by formal specifications. This ensures consistency, reduces errors, and accelerates development through automation.
- **Dual-Output Philosophy**: The project focuses on two primary outputs: a high-quality, deployable textbook, and reusable AI intelligence components (subagents, skills) that can be leveraged for future automation and enhancement.

## 2. Core Principles

- **Library-first**: Prioritize the creation of reusable code libraries and components to promote modularity and reduce redundancy across the project.
- **CLI-first**: Design and implement functionalities with a command-line interface as the primary interaction method for automation and scripting.
- **Test-first**: Develop tests before writing the corresponding code to ensure correctness, facilitate refactoring, and define expected behavior.
- **Spec-first**: All code and content generation MUST be driven by explicit specifications (`spec.md` or equivalent), ensuring alignment with requirements and consistency. No code or content is generated without a validated spec.
- **Reusable Intelligence**: Develop AI components (Claude Code Subagents, Agent Skills) that are generic, modular, and reusable across different parts of the project and potentially in future endeavors.
- **Agents + Subagents Usage**: Leverage a hierarchy of AI agents and specialized subagents for complex tasks, promoting autonomous execution, efficient resource allocation, and clear task decomposition.

## 3. Governance Rules

- **File Creation**: AI will create new files ONLY when explicitly instructed by a specification (`specs/<feature>/spec.md`) or a dedicated command (e.g., `/sp.spec`), strictly following predefined naming conventions and folder structures (e.g., `specs/<feature>/plan.md`). All generated files MUST have a clear purpose tied to a spec.
- **Folder Creation**: AI will create folders as part of a structured command or a feature specification, adhering to the established project directory hierarchy (e.g., `specs/<feature>/`). Folders will be created only when necessary to contain generated artifacts or organize project content.
- **Content Generation**: AI will generate all textual content (e.g., Docusaurus chapters, documentation, configuration files) based on detailed content specifications, ensuring correct formatting (e.g., markdown), internal linking, and adherence to established style guides and structural guidelines.
- **Code Generation Boundaries**: AI will generate code ONLY within the scope defined by a feature's specification. Code generation will respect module boundaries, existing code conventions, and architectural patterns. No speculative or un-specified code generation.
- **Consistency Across Modules**: AI will proactively use shared specifications, templates, and style guides to enforce consistency in code, documentation, and content across all modules and chapters. Automated linting and validation tools will be leveraged.
- **Code Generation via Specifications**: All code generated by AI MUST be directly traceable to a validated formal specification (`specs/<feature>/spec.md`). Any deviation requires explicit update and re-validation of the spec.

## 4. Specification Namespaces

Every primary deliverable and significant component MUST have a corresponding specification file namespace under the `specs/` directory, structured as `specs/<feature-name>/spec.md`.

- **Book Content**: `specs/book-chapters/<chapter-name>/spec.md`
- **RAG Chatbot**: `specs/rag-chatbot/spec.md`
- **Authentication System**: `specs/authentication/spec.md`
- **Personalization System**: `specs/personalization/spec.md`
- **Urdu Translation Feature**: `specs/urdu-translation/spec.md`
- **Reusable Intelligence (Subagents/Skills)**: `specs/reusable-intelligence/<component-name>/spec.md`
- **ROS2 Examples**: `specs/ros2-examples/<example-name>/spec.md`
- **Gazebo/Unity Digital Twin Examples**: `specs/digital-twin-examples/<example-name>/spec.md`
- **NVIDIA Isaac Sim/ROS Examples**: `specs/isaac-sim-ros-examples/<example-name>/spec.md`
- **Vision-Language-Action Robotics**: `specs/vla-robotics/spec.md`
- **Capstone Project**: `specs/capstone-project/spec.md`

## 5. Project Architecture

- **Book System Architecture**: Docusaurus-based static site generation, content authored in markdown (`docs/**/*.md`), automated by Spec-Kit Plus, and generated/managed using Claude Code. Deployed to GitHub Pages via CI/CD. The structure will be defined in `specs/book-chapters/hierarchy/spec.md`.
- **RAG System Architecture**:
    - **Backend**: FastAPI for RESTful API endpoints, defined by `specs/rag-chatbot/api/spec.md`.
    - **Vector Database**: Qdrant Cloud for vector embeddings, schema defined by `specs/rag-chatbot/qdrant-schema/spec.md`.
    - **Metadata Storage**: Neon Serverless Postgres for relational metadata, schema defined by `specs/rag-chatbot/postgres-schema/spec.md`.
    - **Conversational AI**: OpenAI Agents/ChatKit SDK, configured to answer based on selected text context and the full book content. Agent behavior specified in `specs/rag-chatbot/agent-behavior/spec.md`.
- **Auth System Architecture**: Better-Auth for robust user signup and sign-in. Integrates with the personalization system's user profile database. Auth flows and components specified in `specs/authentication/spec.md`.
- **Personalization Pipeline**: User profile creation based on hardware/software background questions during signup/onboarding. This profile directly influences chapter recommendations and content tailoring for the user. Logic defined in `specs/personalization/pipeline/spec.md`.
- **Urdu Translation Mechanism**: A client-side JavaScript toggle/button for each chapter. This will dynamically fetch translations from a specified translation API (e.g., Google Translate API) or render pre-translated content. Implementation details in `specs/urdu-translation/frontend/spec.md`.
- **Claude Subagents Structure**: Hierarchical and specialized subagents designed for specific tasks:
    - `chapter-generation-subagent` (`specs/reusable-intelligence/chapter-gen-subagent/spec.md`)
    - `diagram-generation-subagent` (`specs/reusable-intelligence/diagram-gen-subagent/spec.md`)
    - `code-example-subagent` (for ROS/Gazebo/Isaac, `specs/reusable-intelligence/code-gen-subagent/spec.md`)
    - Each subagent's role, input/output, and tool access will be explicitly defined.
- **Embedding Pipeline**: Text content from Docusaurus chapters (`docs/**/*.md`) will be extracted, preprocessed (chunking, cleaning), and transformed into vector embeddings using a chosen embedding model (e.g., OpenAI Embeddings). These embeddings will then be indexed in Qdrant. Pipeline defined in `specs/embedding-pipeline/spec.md`.
- **Deployment Flow (CI/CD)**: Automated GitHub Actions/Pipelines for:
    - **Book Deployment**: Triggered on pushes to `main`/`master`, builds Docusaurus site, and deploys to GitHub Pages. Defined in `.github/workflows/docusaurus-deploy.yml` and specified in `specs/deployment/book-ci-cd/spec.md`.
    - **RAG System Deployment**: Triggered on pushes to `main`/`master`, builds FastAPI application, deploys to a serverless platform (e.g., Render, Vercel, AWS Lambda). Defined in `.github/workflows/rag-deploy.yml` and specified in `specs/deployment/rag-ci-cd/spec.md`.

## 6. Development Flow (AI-Driven)

1.  **Feature Specification**: A new feature begins with the creation of a detailed `specs/<feature>/spec.md` file, outlining requirements, scope, architecture, and acceptance criteria.
2.  **Spec Validation**: AI MUST validate the `spec.md` for completeness, consistency, and adherence to constitutional principles before proceeding.
3.  **Plan Generation**: Based on the validated spec, AI generates a `specs/<feature>/plan.md`, detailing implementation steps, technical choices, and resource allocation.
4.  **Task Breakdown**: AI generates an actionable `specs/<feature>/tasks.md`, breaking down the plan into small, testable tasks with explicit dependencies.
5.  **Implementation**: AI executes tasks from `tasks.md` by generating code, content, or configurations. Each generated artifact MUST directly address a task and be traceable to the spec.
6.  **Review & Test**: AI performs automated quality checks (linting, unit tests, integration tests) and reviews its own output against the spec and task criteria. Human review is integrated at key checkpoints.
7.  **ADR Creation**: For architecturally significant decisions identified during planning or implementation, AI will suggest the creation of an Architectural Decision Record (`history/adr/<title>.md`) for user approval.
8.  **PHR Generation**: After every significant user interaction or completion of a development stage, AI will automatically generate a Prompt History Record (`history/prompts/<context>/<ID>-<title>.prompt.md`) to document the exchange.

## 7. Development Rules for AI

- **Code Generation without Spec**: AI CANNOT generate any code or content without a validated, explicit specification (`specs/<feature>/spec.md`). All outputs MUST be spec-driven.
- **Spec Validation Mandate**: AI MUST validate every specification (`spec.md`, `plan.md`, `tasks.md`) for adherence to project principles, completeness, and consistency before initiating any generation or implementation based on it.
- **Folder & File Boundaries**: AI will strictly operate within defined folder and file boundaries. Unauthorized creation or modification of files/folders outside designated spec-driven paths is forbidden.
- **Reusable & Modular Libraries**: AI MUST prioritize the design and implementation of small, focused, and reusable code modules (libraries) that promote maintainability, testability, and reduce technical debt.
- **Naming Standards Adherence**: AI MUST strictly follow established naming conventions for files, folders, variables, functions, and classes across the entire codebase to ensure consistency and readability.
- **Deterministic Behavior**: AI's actions and outputs MUST be deterministic, predictable, and justifiable based on the current context, specifications, and constitutional rules. Ambiguous outputs are forbidden.

## 8. Deliverable Standards

- **Book Chapter Quality Guidelines**: Chapters must be technically accurate, well-structured (clear headings, consistent formatting), clear, concise, and engaging. They should include relevant code examples (ROS/Gazebo/Isaac), high-quality diagrams, and practical applications. Content must be free from jargon where possible or clearly explain technical terms.
- **RAG Pipeline Correctness**: The RAG chatbot MUST accurately retrieve the most relevant information from the book content and provide coherent, contextually appropriate, and factual answers. Answers must directly cite sources from the book.
- **Auth & Personalization Correctness**: The authentication system MUST be secure, functional, and user-friendly. The personalization system MUST correctly process user profiles and dynamically tailor chapter content and recommendations based on background and preferences.
- **Translation Correctness**: The Urdu translation mechanism MUST provide accurate, contextually appropriate, and culturally sensitive translations of all chapter content, maintaining the original meaning and technical accuracy.
- **Diagram Generation Rules**: Automated diagrams MUST be clear, legible, technically accurate, and formatted consistently with the textbook's visual style. Diagrams should convey complex information effectively and be easily understandable.

## 9. Quality & Review Requirements

-   **No Hallucinations**: All AI-generated content (text, code, diagrams) MUST be factual and verifiable against reliable sources or project specifications. Any generative output must be checked for accuracy.
-   **No Broken References**: All internal and external links, code references, cross-references within the book, and API endpoints within the code MUST be valid, functional, and up-to-date.
-   **No Undefined APIs**: All API calls within generated code MUST refer to defined and implemented API endpoints. No placeholders or non-existent API calls are permitted.
-   **No Missing Assets**: All images, diagrams, code snippets, and other multimedia assets referenced in the book or code MUST be present, correctly linked, and accessible.
-   **Test Coverage Rules**: All newly generated or modified code MUST adhere to a minimum test coverage threshold (e.g., 80% line coverage) as defined in project standards. Tests must be comprehensive and executable.
-   **AI Self-Review Mechanisms**: AI will perform automated checks, including static analysis (linting, type checking), unit tests, integration tests, and content validation against specifications, before marking tasks as complete or submitting for human review.
-   **Human Review Integration**: Key deliverables (e.g., completed chapters, major code modules, architectural plans) will have explicit human review checkpoints to ensure quality, alignment with vision, and address any AI limitations.

**Version**: 1.0.0 | **Ratified**: 2025-11-29 | **Last Amended**: 2025-11-29
